EE 312 Lecture
2.3.15
==============
Project 2 - cementing the understanding of pointers
          - starting to focus on memory management

Matrix Multiplication

A = [ a, b, c       [ m, n              [ am+bo+cq, an+bp+cr,
      d, e, f ]   x   o, p      =         dm+eo+fq, dn+ep+fr ]
                      q, r ]

Some crashes in test 3 for project 2 are caused by failures in the first function (stage 1)

Practical matrices in memory
    How are they mapped?
    double a[6] = { a, b, c, d, e, f};
    // k is column, j is row
    for (uint32_t k = 0; k < 2; k += 1) {
       a[k*3 + j] = A_kj // Common error in Project 2-- people will scale the rows by the wrong number
        // Scale k by the number of COLUMNS, not rows
    }

    Common solution is to use three nested loops

    FORTRAN and MATLAB use column ordered matrices
    
Matrix Multiplication Cont'd
    scalar multiplication => ans = x * y * z
        t = x * y
        ans = t * y;
    With matrices, dimensions change as you multiply
    (2x3)(3x2)(2x5)(5x2)(3x2) 
    Memory allocation problem: temporary variables are different sizes
    Easiest is to create a separate temp variable for each multiplication
    
    Memory pool- gigantic memory block to store temp variables
        Track the pool with a pointer at the top
        ***** Intersting problem: think about the optimal way to perform multiplication *****

Back to our printf() case study
    From last week's notes:     
	************* KNOW THIS SECTION (TEST MATERIAL) ***************
	When a function is called, a stack frame is generated by the compiler.
	Stack Frame
		First section: all the arguments or parameters
			The frame pointer keeps track of where the beginning of the stack is.
	---------------------------------
	|			Param 2				|
	|_______________________________|	
	|			Param 1				|
	|_______________________________|															___
	|			Return Address		| <- Wherever the PC was before the fcn was called		 	  |		
	|_______________________________|														 	  |- Pure overhead for compiler
	|			Frame Pointer		| <- Which part of the stack are we using right now?		  |
	|_______________________________| <- Frame pointer stores value of previous frame pointer	__|
	|			Local Vars			| <- locals are stored backwards in gcc
	|_______________________________| <- Visual Studio stores locals reverse from gcc
	|			Buffer				| <- ONLY in Visual Studio, used for saving all the fp registers and 3 other registers (76 bytes, 19 ints).
	|_______________________________|

	Note: there are notes on printf() in the "Lecture Notes" section of the repository if you want more info

    ---------------------------------
    |           42                  |
    ---------------------------------
    |           fmt                 | ------> "x is %d\0"
    ---------------------------------

    In order to access the variable parameters on top of fmt, we find the address (&fmt) and add 1.
        remember that address arithmetic is scaled by the declared size of the pointer
    
    Semantic issue with C: compiler promotes any PARAMETER type smaller than int up to a 32 bit int.
                           doesn't scale up arrays of smaller size values

   
Void * Pointers
---------------
    void* p = &x; 
    // It's a pointer when you don't yet know what type it will point to 
    // The address of "nothing in particular"
    print *p gives you a compiler error! You can't read from a void* pointer
    Once you know the appropriate type, put it in a proper pointer

Important concept- design invariance
   
Implementing %s in printf():
    char name[6]={'C', 'r', 'a', 'i', 'g', '\0'};
    printf("Hello %s, how are you?", name);
    next_arg needs to be a pointer to char* name; i.e., next_arg is of type char**
    
     
