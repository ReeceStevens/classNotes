EE 312 Lecture
1.29.15
==============
Logistics-
	Next Thursday's class is cancelled
	Proj 1 due Monday, end of day
	Longest word won't be longer than 127

Pointers
	void star pointers
		
	null pointers
		points to address zero
		Nothing is ever stored in address zero
		example:
			// This crashes on virtually every compiler ever
			// except on AIX (IBM version of UNIX)
			int main (void) {
				int* p = 0;
				printf("%d\n", *p);
			}
		Useful-- if we want to make sure a pointer is pointing to anything, 
			just point it to zero!
		Good for telling a caller function that a process failed.
Looking at printf()
	printf("hello");
	printf("%d %s %d %c", 42, "hello", 65, 65);
	Can accept variable arguments
	Arguments pushed onto the stack in reverse order (i.e. 65, 65, "hello", ...)

	************* KNOW THIS SECTION (TEST MATERIAL) ***************
	When a function is called, a stack frame is generated by the compiler.
	Stack Frame
		First section: all the arguments or parameters
			The frame pointer keeps track of where the beginning of the stack is.
	---------------------------------
	|			Param 2				|
	|_______________________________|	
	|			Param 1				|
	|_______________________________|															___
	|			Return Address		| <- Wherever the PC was before the fcn was called		 	  |		
	|_______________________________|														 	  |- Pure overhead for compiler
	|			Frame Pointer		| <- Which part of the stack are we using right now?		  |
	|_______________________________| <- Frame pointer stores value of previous frame pointer	__|
	|			Local Vars			| <- locals are stored backwards in gcc
	|_______________________________|
	|			Buffer				| <- ONLY in Visual Studio, used for saving all the fp registers and 3 other registers (76 bytes, 19 ints).
	|_______________________________|

	Note: there are notes on printf() in the "Lecture Notes" section of the repository if you want more info

	Writing printf() using putchar(char c);
	When declaring a C funtion in C++:
	// Function prototyping
	extern "C" {
		void putchar(char c);
	}	
	
	void displayDecimal(int x){
		if (x == 0){ // Special case for zero
			putchar('0');
			return;	
		}		
		
		if (x < 0) { // special case for negative numbers
			putchar('-');
			x = -x;
			// Fall through and display absolute value of original
		}

		char digits[10];
		int num_digits = 0;
		while(x != 0){
			char digit = x % 10 + '0'; // Add the offset to reach ASCII numbers
			x = x / 10;
			digits[num_digits] = digit;
			num_digits++;
		}
		while (num_digits) {
			num_digits -= 1;
			putchar(digits[num_digits]);
		}
		return;
	}

	// All the ... syntax does is tells the compiler the fcn can be passed any number of params
	void MyPrintf(char fmt[], ...){ // Could say either char fmt[] or char* fmt-- purely a style choice
		int k = 0;
		while(fmt[k] != 0){
			if (fmt[k] == '%') { // escape sequence
				// Determine type of the next arg we have
				if (fmt[k+1] == 'd'){ // display in decimal
					int* p = (int*) &fmt;
					p = p + 1;
					int x = *p;	
					displayDecimal(x);
				} else if (fmt[k+1] == 'c') { // display ASCII
		
				} else if (fmt[k+1] == '%') { // display a % character
				} else { // whatttttt		
				}
				k = k + 2;
			} else {
				putchar(fmt[k]);
				k = k + 1;	
			}
		}
	}

	int main(void) {
		MyPrintf("Hello World\n");
		MyPrintf("x is %d\n", 42);
	}
