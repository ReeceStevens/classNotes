EE 312 Lecture
4.14.15
==============
Finishing up trees
------------------
Remember from last time that there is only
one unique location where you can place a new number
in a binary search tree!
        10
    5       20
      7 <-- must go here!

If numbering from 1 to num_elements, there
is only one way that you can insert all the numbers in subsequent 
order.
        o
    o       o
  o o       o o
To find the successor to a node:
    1. It's the smallest node in the right subtree
        - essentially, go right as many times as you possibly can.
    2. If you don't have a right subtree, go up until you reach your
        first right subtree.
    You know you've hit the right value because the next value makes
    you fall out of the tree!

Now writing remove:
    1. Leaf - easy. Go up to the parent and make the pointer to the leaf a null. (Actually don't need this case, 2 or 3 covers it)
    2. Right is null - Go up to the parent and move the parent's pointer to the node's child.
    3. Left is null - Go up to the parent and move the parent's pointer to the node's child. (Case 4 covers this case, but not case 1)
    4. Neither is null - More complicated.
        Don't actually remove the node, just replace the value!
        Duplicates to the right are okay, so we can just copy the smallest value in the right subtree
        Also can pick the largest value in the left subtree (but don't pick this option, since we defined
            our tree to strictly smaller to the left).
        Solution: Steal successor!
            Critical Properties of BST (and reaching case 4)
            1. Successor must exist and must be in right subtree.
            2. Successor has NO LEFT SUBTREE. Can remove by case three.

Code Implementation- only have to code case 2 and 4!

Node* removeTree(Node* root, int32_t v) {
    // Step 1: find the node containing that value.
    Node* p = root;
    while(p && p->value != v) { // Check for null ptr, value doesn't exist in tree. Also handles null tree case.
        if (v<p->value) {
            p = p->left;
        } else {    
            p = p->right;
        }
    }
    if (!p) { return root; } // Value doesn't exist in our tree. Get out!

    // Step 2: Decide which case applies.
    if (p->right == nullptr) { // easy, no right subtree
        Node* parent = p->parent; // Just for making the code easier to write
        
        Node* child = p->left;
        if (parent == nullptr){ // Detect the special case.
            root = child;
            if (child) {child->parent = nullptr; }
            child->parent = nullptr;
            return root;      
        }
        if (p == parent->left) {
            parent->left = child;
        } else {
            parent->right = child; 
        }
        if (child) { child->parent = parent; }
    } else { // Hard case, right subtree exists
        Node* s = successor(p); // since there's a right subtree, there has to be a successor. 
        // Successor is the SMALLEST VALUE IN THE RIGHT SUBTREE. Therefore it has no left child.
        // Steal value from the successor and remove the successor.
        p->value = s->value;
        Node* parent = s->parent;
        Node* child = s->right;
        if (s == parent->left) {
            parent->left = child;
        } else {
            parent->right = child; 
        }
        if (child) { child->parent = parent; } // protect in case s->right is null.
        delete s;
    }

    return root;
} 
